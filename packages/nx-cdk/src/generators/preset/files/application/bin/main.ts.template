#!/usr/bin/env node
import { MicroserviceChecks, VersionFunctionsAspect } from '@aligent/cdk-aspects';
import { App, Aspects, Duration, Tags } from 'aws-cdk-lib';
import { Runtime } from 'aws-cdk-lib/aws-lambda';
import { ApplicationStage } from '../lib/service-stacks.js';

// TODO: [MI-277] Move these aspects to @aligent/cdk-aspects package for reuse across projects
import { LogGroupDefaultsAspect } from '../_internal/log-group-defaults-aspect.js';
import { NodeJsFunctionDefaultsAspect } from '../_internal/nodejs-function-defaults-aspect.js';
import { StepFunctionDefaultsAspect } from '../_internal/step-function-defaults-aspect.js';

const APPLICATION_CONTEXT = { NAME: '<%= name %>-int', OWNER: 'aligent' } as const;
const STAGE_NAMES = { DEV: 'dev', STG: 'stg', PRD: 'prd' } as const;

const app = new App({ context: APPLICATION_CONTEXT });
Tags.of(app).add('OWNER', APPLICATION_CONTEXT.OWNER);

/**
 * Apply Application-Level Aspects
 * These aspects are applied to all resources across all stages
 */
Aspects.of(app).add(
    new NodeJsFunctionDefaultsAspect({
        runtime: Runtime.NODEJS_<%= nodeRuntime %>,
        memorySize: 256,
        timeout: Duration.seconds(3),
    })
);
Aspects.of(app).add(new StepFunctionDefaultsAspect());
Aspects.of(app).add(new MicroserviceChecks());

/**
 * Static Stage Creation Approach
 *
 * We use static stage creation (explicitly defining dev, stg, prd) for several reasons:
 *
 * 1. **Predictability**: All stages are known at synthesis time, making the CDK app
 *    behavior deterministic and easier to reason about.
 *
 * 2. **Type Safety**: Static definitions provide better IDE support, autocompletion,
 *    and compile-time type checking for stage-specific configurations.
 *
 * 3. **Explicit Configuration**: Each stage's unique settings (e.g., log retention
 *    durations, aspects) are clearly visible in the code without needing to trace
 *    through dynamic logic.
 *
 * 4. **Simpler Deployment**: CDK can synthesize all stages in a single pass without
 *    requiring runtime context lookups or conditional logic.
 *
 * 5. **CI/CD Integration**: Static stages integrate seamlessly with standard CI/CD
 *    pipelines where environment configuration is managed externally.
 *
 * @see {@link https://dev.to/aws-heroes/how-to-use-aws-cdk-stage-and-when-to-choose-static-vs-dynamic-stack-creation-35h|Static vs Dynamic Stack Creation}
 *
 * @remarks
 * Aspects visit all constructs in the tree after synthesis and can modify them
 * (e.g., applying log retention policies, enabling tracing).
 */

const dev = new ApplicationStage(app, STAGE_NAMES.DEV);
Aspects.of(dev).add(new LogGroupDefaultsAspect({ duration: 'SHORT' }));

const stg = new ApplicationStage(app, STAGE_NAMES.STG);
Aspects.of(stg).add(new LogGroupDefaultsAspect({ duration: 'MEDIUM' }));

/**
 * Production Stage
 * - Long log retention (2 years) for compliance and debugging
 * - Resources retained on stack deletion
 * - Lambda functions and Step Functions are automatically versioned, enabled for zero-downtime deployments
 */
const prd = new ApplicationStage(app, STAGE_NAMES.PRD);
Aspects.of(prd).add(new LogGroupDefaultsAspect({ duration: 'LONG' }));
Aspects.of(prd).add(new VersionFunctionsAspect());
